#!/usr/bin/env ruby
require 'gli'
require 'yaml'

begin # XXX: Remove this begin/rescue before distributing your app
require 'timetracker'
rescue LoadError
  STDERR.puts "In development, you need to use `bundle exec bin/timetracker` to run your app"
  STDERR.puts "At install-time, RubyGems will make sure lib, etc. are in the load path"
  STDERR.puts "Feel free to remove this message from bin/timetracker now"
  exit 64
end

include GLI::App

program_desc 'Track, manage, and query a task tree where each node is a potential project or task'

version Timetracker::VERSION

#desc 'Describe some switch here'
#switch [:s,:switch]

#desc 'Describe some flag here'
#default_value 'the default'
#arg_name 'The name of the argument'
#flag [:f,:flagname]
#
#


# specify special date format
accept(Date) do |string|
      Date.parse(string)
end

desc 'Specify the file where the task tree lives'
arg_name 'path'
default_value File.join(ENV['HOME'],'.bricktree.yml')
flag [:t,:tasktree]

desc 'Be verbose'
switch 'verbose'


desc 'Show task tree'
long_desc <<EOS
List the tasks in your task tree, possibly including time worked.  By default,
this will list all tree nodes and not other information.
EOS

#arg_name 'Describe arguments to list here'

command [:show,:sh] do |c|

    #c.desc 'Describe a switch to list'
    #c.switch :s

    c.desc 'Specify a date to show information: format mm.dd.yy'
    c.default_value 'today'
    c.flag [:d,:day]
    
    c.desc 'Specify a date range to show information; format mm.dd.yy-mm.dd.yy'
    c.flag [:r,:range]

    #c.action do |global_options,options,args|

        # Your command logic here

        # If you have any errors, just raise them
        # raise "that command made no sense"

        #puts "list command ran"
    #end
    
    c.desc 'Show tree with names'
    c.command :tree do |c2|
        c2.action do |global_options,options,args|
            $brick_tree.prettyPrintFullTree()
        end
    end
        
    c.desc 'Show show time worked for each brick'
    c.command [:to,:today] do |c2|
        c2.action do |global_options,options,args|
            $brick_tree.printSubtreeTodayTime()
        end
    end
    
    c.desc 'Show show time worked for each brick'
    c.command [:total] do |c2|
        c2.action do |global_options,options,args|
            $brick_tree.printSubtreeTotalTime()
        end
    end
    
    c.desc 'Show brick time records for day <def:today>'
    c.command [:tr, :time] do |c2|
        c2.action do |global_options,options,args|
            # Default to the range of the current week 
            daySecs = (60*60*24)
            dateBegin = TimeUtils.getLastSundayTime
            dateEnd = Time.now 
            unless(options[:r].nil?)
                puts "Time Record for range #{options[:r]}\n"
                # format : mm.dd.yy-mm.dd.yy
                dateStr = options[:r].split('-')
                dateB = dateStr[0].split('.')
                dateE = dateStr[1].split('.')
                dateBegin = Time.new("20#{dateB[2]}", dateB[0], dateB[1])
                # Note that we add one day here because the time being returned
                # is the first hour of the day, and as such we need to include
                # time up to midnight of the next day.
                dateEnd = Time.new("20#{dateE[2]}", dateE[0], dateE[1]) + daySecs
            else
                unless(options[:d].nil?)
                    puts "Time Record for #{options[:d]}\n"
                    if(options[:d] != "today")
                        # Format is mm:dd:yy
                        dateStr = options[:d].split('.')
                        dateBegin = Time.new("20#{dateStr[2]}", dateStr[0], dateStr[1])
                        dateEnd = dateBegin + daySecs 
                    end
                end
            end
            $brick_tree.printTimeRecords(dateBegin, dateEnd)
        end
    end

    c.default_command :tree
end

desc 'Add a new brick'
#arg_name 'Describe arguments to add here'
command :add do |c|

    c.desc 'Name of the brick to add'
    c.flag [:b,:brick]

    c.desc 'Add the new brick to this parent'
    c.flag [:p,:parent], :default_value => NIL,
                         :arg_name => "parent",
                         :type => String,
                         :desc => "The parent to add the new brick to."
    
    c.desc 'Comma separated list of tags'
    c.flag [:t,:tags], :default_value => [],
                       :arg_name => "tags",
                       :type => Array,
                       :desc => "List of tags"

    # the default action is to add the brick to the parent
    c.action do |global_options,options,args|
        # Argument validation
        if(options[:b].nil? && options[:brick].nil?)
            help_now!('Must give a new brickname')
        elsif (options[:p].nil? && options[:parent].nil?)
            help_now!('Must provide a parent to attach the new brick')
        end

        puts "Adding brick: #{options[:b]} to parent: #{options[:p]}, with tags: #{options[:t]}"

        $brick_tree.addBrick(options[:b], options[:p], options[:t])

        if(global_options[:verbose]) then
            print "\nResulting Tree: \n"
            $brick_tree.prettyPrintFullTree()
        end
    end
end

desc 'Remove a new brick'
arg_name 'brick_id'
command [:rm,:remove] do |c|

    c.desc "Remove all of a subtree starting at the brick provided"
    c.command [:st,:subtree] do |c|
        c.action do |global_options,options,args|
            $brick_tree.removeSubTree(args[0])
            if(global_options[:verbose])
                then
                print "\nResulting Tree: \n"
                $brick_tree.prettyPrintFullTree()
                $brick_tree.to_yaml
            end
        end
    end

    c.action do |global_options,options,args|
        raise "Not yet implemented"
        if(global_options[:verbose])
            then
            print "\nResulting Tree: \n"
            $brick_tree.prettyPrintFullTree()
        end
    end

    c.default_command :subtree
end

desc 'Record time'
arg_name 'time_record'
command [:re,:record] do |c|

    c.desc 'Name of the brick to record time on'
    c.flag [:b,:brick]
    
    c.desc 'Name of the task to record time on'
    c.flag [:t,:task]
    
    c.desc 'Name of tags to add to time record'
    c.flag [:tags]


    c.action do |global_options,options,args|
    
        if(options[:b].nil? && options[:brick].nil?)
            help_now!('Must provide a brickname to record time to')
        end

        ttimer = Timer.new
        puts ttimer.startTime
        quit = false
        
        # This thread prints out the timer
        tOut = Thread.new {
            # Prints out the time to STDOUT for the user to see the duration
            print "Command: r: reset, c: complete, q: quit\n"
            while 1
                print "\r\t", ttimer.timeDiffNowStr(), "\tCommand [r,c,q]: "
                sleep(1)
            end
        }

        # This thread waits for input and manages it. Notice that we need to
        # kill the output thread if we want the display to be coherant after
        # the user has entered data.
        while !quit
            comm = gets.chomp()
            if (comm =~ /r/) then
                ttimer.printTimeDiffNow()
                puts "\nRestarting...\n"
                ttimer.start
                puts ttimer.start
            elsif (comm =~ /c/) then
                ttimer.stop
                tOut.exit
                puts "Stopping timer with time tracked: #{ttimer.printTimeDiffNow}"
                break
            elsif (comm =~ /q/) then
                tOut.exit
                puts "Quiting..."
                quit = true
            end
        end

        unless(quit)
            print "Would you like to record this time to the brick? [y/N] "
            if (gets.chomp() =~ /[yY]/)
                $brick_tree.recordTime(options[:t],
                                       options[:b], 
                                       ttimer.startTime, 
                                       ttimer.endTime, 
                                       options[:tags]) 
            end
        end

        if(global_options[:verbose])
            #print "\nResulting Tree: \n"
            #$brick_tree.prettyPrintFullTree()
            #puts $brick_tree.to_yaml
        end
    end

    #c.default_command :subtree
end

pre do |global,command,options,args|
    # Pre logic here
    # Return true to proceed; false to abort and not call the
    # chosen command
    # Use skips_pre before a command to skip this block
    # on that command only

    #$task_tree_serializer = BrickTree::TaskListYamlSerializer.new(global[:t])
    #$task_list = $task_list_serializer.read
    unless File.exists?(global[:t])
        puts "Data file does not exist. Creating new one."
        $brick_tree = BrickTree.new
    else
        $brick_tree = YAML.load_file(global[:t])
    end
    true
end

post do |global,command,options,args|
    # Post logic here
    # Use skips_post before a command to skip this
    # block on that command only
    File.open(global[:t], 'w') {|f| f << $brick_tree.to_yaml }
end

on_error do |exception|
    # Error logic here
    # return false to skip default error handling
    true
end

exit run(ARGV)
